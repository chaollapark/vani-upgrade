<?php
/**
 * Changes in 0.2:
 *  * Use "-" as list item to create a separator
 * Changes in 0.3:
 *  * Added CSS class item# and even/odd to list items to make styling easyer
 * Changes in 0.4:
 *  * Added a small arrow ">" for each menu (with subitems) displayed on the right.
  * Changes in 0.4.1:
 *  * BUGFIX: last </li> was missing
 */
if (!defined('MEDIAWIKI')) {
    exit(1) ;
}
$wgExtensionCredits['other'][] = array(
    'name' => 'MenuSidebar',
    'version' => '0.4.1',
    'author' => 'Wolfgang St&ouml;ttinger',
    'description' => 'Sidebar can be displayed as a Menu',
    'url'     => 'http://www.mediawiki.org/wiki/Extension:CSS_MenuSidebar',
);


/* If this is set to true, each ListItem is parsed by the MediaWiki parser 
 * which allows more flexible inclusion of MediaWiki content e.g links to files. 
 * If set to false, a similar behaviour to the normal SideBar is used.
 * 
 * Be careful when using this!
 */
$wgParseListItems = false;

$wgHooks['SkinBuildSidebar'][] = 'fnNewSidebarItem';

function fnNewSidebarItem( $skin, &$bar ) {
        
	$bar[ 'heading' ] =  array(
		array(
			'text'   => 'TestPage',
			'href'   => 'http://192.168.2.122/wiki/index.php/TestPage',
			'id'     => 'n-login',
			'active' => ''
		),
		array(
			//'subheading' => array(
				'text'   => 'TestPage2',
				'href'   => 'http://192.168.2.122/wiki/index.php/TestPage2',
				'id'     => 'n-login2',
				'active' => ''
			//)
		)
	);
}

//$wgHooks['SidebarBeforeOutput'][] = 'fnMenuSidebar';

function fnMenuSidebar($skin, &$bar) {
	global $wgParser, $wgUser, $wgTitle, $wgParseListItems;
	
	//wfProfileIn( __METHOD__ );
		
	$title = Title::newFromText("MenuSidebar",NS_MEDIAWIKI);	
	/** Use the revision directly to prevent other hooks to be called */
	$rev = Revision::newFromTitle( $title );
    $content = $rev->getContent( Revision::RAW );
    $text = ContentHandler::getContentText( $content );

    if ($rev)
		$lines = explode("\n", $text);
    
	if ($lines && count($lines) > 0) {
		
		$opt = null; 
		 
		/* init the parser */
		if ($wgParseListItems) {
			if (!is_object($wgParser)) {
			    $wgParser = new Parser();
			    $opt = $wgParser->mOptions;
			}
			if (!is_object($opt)) {
			    $opt = ParserOptions::newFromUser($wgUser);
			}
		}

		for ($i = 0; $i < sizeof($lines); $i++) {
			$line = $lines[$i];
			
			if (strpos($line, '**') === 0 && $i > 0) {// entry in a deeper level:
				$content = '
            <div class="menuSidebar">
                lalalala
				<ul>
					' . fnBuildList($lines,$i,1, $opt) . '
				</ul>
			</div>
			';
				$bar[$title] = $content;
				$i--;
			}
			else { // use Entry as Title:
				$title = trim($line, '* ');
			}	
		}
	}
	return true;
}

function fnBuildList($lines,&$i, $level, $opt) {
	global $wgParser, $wgTitle, $wgParseListItems;
	
	$content = "";
	$closeLI = false;
	$itemCount = 0;
	for (;$i < sizeof($lines); $i++) {
		$itemCount++;		
		
  		$class = "item{$itemCount}"; 
  		$class .= ($itemCount % 2 == 0 ? " even" : " odd"); 
  		
		$line = $lines[$i];
		$line = substr($line,$level);
				
		if (strpos($line, '**') === 0) {// entry in a deeper level:		
			// inject a &gt; at the end of the line
			$content = rtrim($content); 
			if (strrpos($content,'</a>') === strlen($content) - 4) {
				$content = substr($content,0,-4) . "<em>&gt;</em></a>"; 
			}

			$content .= '
				<div><ul>
					' .fnBuildList($lines,$i,$level+1, $opt) . '
				</ul></div>
				';
			$i--;
			$itemCount--;
		}
		else if (strpos($line, '*') === 0) { // entry in this level:
			if ($closeLI) { //workaround to close the last LI 
				$content .= "</li>";
				$closeLI = false;
			}
			if ($wgParseListItems) {
				$text = $wgParser->parse(trim($line, '* '),$wgTitle,$opt,true,true)->getText();
				$text = substr(trim($text),3,-5); // removes <p> and \n</p> that is generated by the parser
				
				if (trim($text) == "-"){
					$class .= " separator";
					$text = "";
				}
				if (strpos($text, '<a') !== 0) 
  					$text = "<a>" . $text . "</a>"; // this is needed to display normal text correctly
		
				$content .= "<li class=\"$class\">$text";
				$closeLI = true;
			}
			else
			{
				if (strpos($line, '|') !== false) {
					$line = array_map('trim', explode( '|' , trim($line, '* '), 2 ) );
					$link = wfMessage( $line[0] )->inContentLanguage()->text();
					if ($link == '-')
						continue;
				
					$text = wfMessage($line[1], 'parsemag')->text();
					if (wfMessage($line[1])->inContentLanguage()->isBlank())
						$text = $line[1];
					if (wfMessage($line[0])->inContentLanguage()->isBlank())
						$link = $line[0];
				
					if ( preg_match( '/^(?:' . wfUrlProtocols() . ')/', $link ) ) {
						$href = $link;
					} else {
						$title = Title::newFromText( $link );
						if ( $title ) {
							$title = $title->fixSpecialName();
							$href = $title->getLocalURL();
						} else {
							$href = 'INVALID-TITLE';
						}
					}
					$href = htmlspecialchars($href);
					$text = htmlspecialchars($text);
					$content .= "<li class=\"$class\"><a href=\"$href\">$text</a>";
					$closeLI = true;
				}
				else {
					if (trim($line) == "-") {
						$class = " separator";
						$text = "";
					}
					
					$text = htmlspecialchars( trim($line, '* '));
					$content .= "<li class=\"$class\"><a>$text</a>";
					$closeLI = true;
				}
			}
		}
		else {
			if ($closeLI) { //workaround to close the last LI
				$content .= "</li>";
				$closeLI = false;
			}
			break; 
		}	
	}
	if ($closeLI) { //workaround to close the last LI 
		$content .= "</li>";
		$closeLI = false;
	}
	return $content;
}